package main

import "fmt"

/**
多重循环控制
	介绍:
		1) 将一个循环放在另一个循环体内，就形成了嵌套循环。在外边的for称为外层循环，在里面的for循环称为内层循环
			建议一般使用两层，最多不要超过3层
		2) 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，
			才可结束外层的当次循环，开始下一次的循环
		3) 设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行 m*n次

*/
func main() {
	// 案例

	// 1.打印金字塔经典案例
	/**
	编程思路
		1) 打印一个矩形
		* * *
		* * *
		* * *

		2) 打印半个金字塔
		*			1个*
		* *			2个*
		* * *		3个*
				星数=层数

		3) 打印整个金字塔
					层数	*数			  *数规律	空格数		空格数规律
	       *		1层		1个*    	 2*层数-1    空格 2     总层数-当前层数
	     * * *		2层		3个*		 2*层数-1	空格 1     总层数-当前层数
		* * * * *	3层		5个*		 2*层数-1    空格 0     总层数-当前层数

		4) 将层数做成一个变量

		5) 打印空心金字塔

	       *
	     *   *
		* * * * *
			分析：
			1) 在我们给每行打印*时，需要考虑是打印* 还是打印空格
			2) 我们分析的结果是，每层第一个和最后一个是打印*，其他就应该是空的，即输出空格
			3) 我们还分析到一个例外情况，最后层(底层)是全部打*

	*/
	var totalLevel int = 9
	// i 表示层数
	for i := 1; i <= totalLevel; i++ {
		// 在打印*前先打印空格
		for k := 1; k <= totalLevel-i; k++ {
			fmt.Print(" ")
		}
		// j 表示每层打印多少 *
		for j := 1; j <= (2*i - 1); j++ {
			if j == 1 || j == 2*i-1 || i == totalLevel {
				fmt.Print("*")
			} else {
				fmt.Print(" ")
			}

		}
		fmt.Println()
	}

	// 2.打印九九乘法表经典案例
	/**
	1*1=1
	1*2=2	2*2=4
	1*3=3	2*3=6	3*3=9
	*/

	// i 表示层数
	var num int = 9
	for i := 1; i <= num; i++ {
		for j := 1; j <= i; j++ {
			fmt.Printf("%v * %v = %v \t", j, i, j*i)
		}
		fmt.Println()
	}
}
