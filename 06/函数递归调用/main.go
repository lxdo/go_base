package main

import "fmt"

/**
函数递归调用 【难点】

基本介绍：
	一个函数在函数体内又调用了本身，我们称为递归调用

重要原则:
	1) 执行一个函数时，就创建一个新的受保护的独立空间(新函数栈)
	2) 函数的局部变量是独立的，不会相互影响
	3) 递归必须向退出递归的条件逼近，否则就是无限递归了
	4) 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁原则
		同时当函数执行完毕或者返回时，该函数本身也会被系统销毁
*/

func main() {

	// 调用递归函数
	test(4)
	test2(4)
	fmt.Println("第3位斐波那契数=", fbn(3))
	fmt.Println("第4位斐波那契数=", fbn(4))
	fmt.Println("第5位斐波那契数=", fbn(5))
	fmt.Println("f(1)=", f(1))
	fmt.Println("f(5)=", f(5))
	fmt.Println("第1天桃子数量是", p(1))
	fmt.Println("第9天桃子数量是", p(9))
	fmt.Println("第10天桃子数量是", p(10))
}

// 函数递归调用案例
func test(n int) {
	if n > 2 {
		n-- // 递归必须向退出递归的条件逼近，否则就是无限递归了
		test(n)
	}
	fmt.Println("test n =", n)
}

// 函数递归调用案例
func test2(n int) {
	if n > 2 {
		n--
		test2(n)
	} else {
		fmt.Println("test2 n=", n)
	}
}

// 函数递归调用练习
// 1.斐波那契数： 1,1,2,3,5,8,13...
// 使用递归的方式， 求出整数n位上斐波那契数是什么
/**
思路
	1) n=1 | n=2  返回 1
	2) n>=2，返回前面两个数的和  n位上的数=f(n-1)+f(n-2)
*/

func fbn(n int) int {
	if n == 1 || n == 2 {
		return 1
	} else {
		return fbn(n-1) + fbn(n-2)
	}
}

// 2.求函数值
// 已知 f(1)=3; f(n)=2*f(n-1)+1; 用递归的思想编程 求出 f(n)的值

func f(n int) int {
	if n == 1 {
		return 3
	} else {
		return 2*f(n-1) + 1
	}
}

// 3.猴子吃桃子问题

/**
有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个。以后每天猴子都吃其中的一半，然后再多吃一个。
当到第十天时，想再吃时(还没吃),发现只有1个桃子了。问题：最初共多少个桃子

思路分析:
		1) 第10天   1个                           1个
		2) 第9天   (第10天个数+1)*2              x/2-1=1  x=(1+1)*2   4个
		3) 第8天   (第9天个数+1)*2               x/2-1=4  x=(4+1)*2   10个
     规律： 第n天   (第n+1天个数+1)*2                p(n)=(p(n+1)+1)*2
*/
// 1<=n<10
func p(n int) int {
	if n < 1 || n > 10 {
		return 0
	}
	if n == 10 {
		return 1
	} else {
		return (p(n+1) + 1) * 2
	}
}

