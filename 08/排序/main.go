package main

import "fmt"

/**
排序
	介绍:
		排序是将一组数据,依指定的顺序进行排列的过程
	排序的分类:
		1)内部排序
			指将需要处理的所有数据都加载到内部存储器(内存)中进行排序 (包括 交换式排序法、选择式排序法和插入式排序法)

		2)外部排序法
			数据量过大,无法全部加载到内存中,需要借助外部存储进行排序 (包括合并排序法和直接合并排序法)

*/

/**
交换式排序
	交换式排序属于内部排序法，是运用数据值比较后，依判断规则对数据位置进行交换，以达到排序的目的

	交换式排序法又可分为两种
		1) 冒泡排序法
				冒泡排序的基本思想是:通过对待排序序列从后向前(从下标较大的元素开始),依次比较相邻元素的排序码，若发现逆序则交换，
				使排序码较小的元素逐渐从后部移向前部(从下标较大的单元移向下标较小的单元)，就像水底下的气泡一样逐渐向上冒

				因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程
				中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较
		2) 快速排序法
*/

// 冒泡排序案例:将五个无序:24,69,80,57,13使用冒泡排序法将其排成一个从小到大的有序数列
func BubbleSort(arr *[5]int) {
	fmt.Println("排序前 arr=", *arr)

	for i := 0; i < len(*arr)-1; i++ { // 排序的轮数
		fmt.Println("第", i+1, "轮排序")
		// 完成第一轮排序(外层第1次)
		for j := 0; j < len(*arr)-1-i; j++ { // 每轮排序的次数
			// 每一轮从第一个数开始,依次比较相邻两个数大小，如果前面数比后面数大，就交换
			if (*arr)[j] > (*arr)[j+1] {
				// 如果前面数比后面数大，就交换
				(*arr)[j], (*arr)[j+1] = (*arr)[j+1], (*arr)[j]
			}
			fmt.Println("第", i+1, "轮 第", j+1, "次排序结果 arr=", (*arr))
		}
		fmt.Println("第", i+1, "轮排序结果 arr=", (*arr))
	}

	fmt.Println("排序后 arr=", (*arr))
}
func main() {
	// 冒泡排序

	// 定义数组
	arr := [5]int{24, 69, 80, 57, 13}

	// 将数组传递给一个函数，完成冒泡排序
	BubbleSort(&arr)
	// 按地址传值 变量函数内改变 函数外也会改变
	fmt.Println("排序后 arr=", (arr))

}
