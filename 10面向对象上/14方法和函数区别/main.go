package main

import "fmt"

/**
方法和函数区别

1)  调用方式不一样
	函数的调用方式: 函数名(实参列表)
	方法的调用方式: 变量.方法名(实参列表)
2)  对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然
3)  对于方法(如struct的方法)，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以
*/

// 结构体
type Person struct {
	Name string
}

// 函数
// 接收者为值类型
func test01(p Person) {
	fmt.Println("test01=", p.Name)
}

// 函数
// 接收者为指针类型
func test02(p *Person) {
	fmt.Println("test02=", p.Name)    // 结构体变量指针调用属性的简写 等价于 (*p).Name
	fmt.Println("test02=", (*p).Name) // 等价于 p.Name
}

// 方法
// 接收者为值类型
func (p Person) test03() {
	fmt.Println("test03=", p.Name)
}

// 方法
// 接收者为指针类型
func (p *Person) test04() {
	fmt.Println("test04=", p.Name)
}
func main() {
	// 2)  对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然
	p := Person{"tom"}
	test01(p)  // 接收者为值类型只能传值类型参数
	test02(&p) // 接收者为指针类型只能传指针类型参数

	// 3)  对于方法(如struct的方法)，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以
	p.test03()    // test03接收者为值类型  p为结构体变量 是值类型
	(&p).test03() // test03接收者为值类型  &p为结构体变量指针 是引用类型
	// 从形式上看是传入地址 ，但其实还是传入p的值，还是值拷贝(这个是由方法的形参决定的)
	// 方法中p改变不会影响方法外的p
	// 只是语法上支持 解析时还是解析为p.test03()

	(&p).test04() // test04接收者为指针类型 &p为结构体变量指针 是指针类型
	p.test04()    // test04接收者为指针类型 p为结构体变量 是值类型
	// 等价于 (&p).test04() 编译器给我们做了优化处理
	// 从形式上看是传入p的值，但其实还是传入p的地址，还是地址拷贝(这个是由方法的形参决定的)
	// 方法中p改变会影响方法外的p
	// 只是语法上支持 解析时还是解析为(&p).test04()


	/*
	不管调用形式是什么，真正决定是值拷贝还是地址拷贝，看这个方法的形参是和哪个类型绑定，
	如果是和值类型绑定 比如 (p Person),则是值拷贝 ，如果是和指针类型绑定，比如 (p *Person)则是地址拷贝
	 */

}
